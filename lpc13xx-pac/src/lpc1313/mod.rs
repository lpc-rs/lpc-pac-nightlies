#![doc = "Peripheral access API for LPC13XX microcontrollers (generated using svd2rust v0.25.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.25.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
extern "C" {
    fn PIO0_0();
    fn PIO0_1();
    fn PIO0_2();
    fn PIO0_3();
    fn PIO0_4();
    fn PIO0_5();
    fn PIO0_6();
    fn PIO0_7();
    fn PIO0_8();
    fn PIO0_9();
    fn PIO0_10();
    fn PIO0_11();
    fn PIO1_0();
    fn PIO1_1();
    fn PIO1_2();
    fn PIO1_3();
    fn PIO1_4();
    fn PIO1_5();
    fn PIO1_6();
    fn PIO1_7();
    fn PIO1_8();
    fn PIO1_9();
    fn PIO1_10();
    fn PIO1_11();
    fn PIO2_0();
    fn PIO2_1();
    fn PIO2_2();
    fn PIO2_3();
    fn PIO2_4();
    fn PIO2_5();
    fn PIO2_6();
    fn PIO2_7();
    fn PIO2_8();
    fn PIO2_9();
    fn PIO2_10();
    fn PIO2_11();
    fn PIO3_0();
    fn PIO3_1();
    fn PIO3_2();
    fn PIO3_3();
    fn I2C0();
    fn CT16B0();
    fn CT16B1();
    fn CT32B0();
    fn CT32B1();
    fn SSP0();
    fn UART();
    fn USB();
    fn USBFIQ();
    fn ADC();
    fn WDT();
    fn BOD();
    fn PIO_3();
    fn PIO_2();
    fn PIO_1();
    fn PIO_0();
    fn SSP1();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 58] = [
    Vector { _handler: PIO0_0 },
    Vector { _handler: PIO0_1 },
    Vector { _handler: PIO0_2 },
    Vector { _handler: PIO0_3 },
    Vector { _handler: PIO0_4 },
    Vector { _handler: PIO0_5 },
    Vector { _handler: PIO0_6 },
    Vector { _handler: PIO0_7 },
    Vector { _handler: PIO0_8 },
    Vector { _handler: PIO0_9 },
    Vector { _handler: PIO0_10 },
    Vector { _handler: PIO0_11 },
    Vector { _handler: PIO1_0 },
    Vector { _handler: PIO1_1 },
    Vector { _handler: PIO1_2 },
    Vector { _handler: PIO1_3 },
    Vector { _handler: PIO1_4 },
    Vector { _handler: PIO1_5 },
    Vector { _handler: PIO1_6 },
    Vector { _handler: PIO1_7 },
    Vector { _handler: PIO1_8 },
    Vector { _handler: PIO1_9 },
    Vector { _handler: PIO1_10 },
    Vector { _handler: PIO1_11 },
    Vector { _handler: PIO2_0 },
    Vector { _handler: PIO2_1 },
    Vector { _handler: PIO2_2 },
    Vector { _handler: PIO2_3 },
    Vector { _handler: PIO2_4 },
    Vector { _handler: PIO2_5 },
    Vector { _handler: PIO2_6 },
    Vector { _handler: PIO2_7 },
    Vector { _handler: PIO2_8 },
    Vector { _handler: PIO2_9 },
    Vector { _handler: PIO2_10 },
    Vector { _handler: PIO2_11 },
    Vector { _handler: PIO3_0 },
    Vector { _handler: PIO3_1 },
    Vector { _handler: PIO3_2 },
    Vector { _handler: PIO3_3 },
    Vector { _handler: I2C0 },
    Vector { _handler: CT16B0 },
    Vector { _handler: CT16B1 },
    Vector { _handler: CT32B0 },
    Vector { _handler: CT32B1 },
    Vector { _handler: SSP0 },
    Vector { _handler: UART },
    Vector { _handler: USB },
    Vector { _handler: USBFIQ },
    Vector { _handler: ADC },
    Vector { _handler: WDT },
    Vector { _handler: BOD },
    Vector { _reserved: 0 },
    Vector { _handler: PIO_3 },
    Vector { _handler: PIO_2 },
    Vector { _handler: PIO_1 },
    Vector { _handler: PIO_0 },
    Vector { _handler: SSP1 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - PIO0_0"]
    PIO0_0 = 0,
    #[doc = "1 - PIO0_1"]
    PIO0_1 = 1,
    #[doc = "2 - PIO0_2"]
    PIO0_2 = 2,
    #[doc = "3 - PIO0_3"]
    PIO0_3 = 3,
    #[doc = "4 - PIO0_4"]
    PIO0_4 = 4,
    #[doc = "5 - PIO0_5"]
    PIO0_5 = 5,
    #[doc = "6 - PIO0_6"]
    PIO0_6 = 6,
    #[doc = "7 - PIO0_7"]
    PIO0_7 = 7,
    #[doc = "8 - PIO0_8"]
    PIO0_8 = 8,
    #[doc = "9 - PIO0_9"]
    PIO0_9 = 9,
    #[doc = "10 - PIO0_10"]
    PIO0_10 = 10,
    #[doc = "11 - PIO0_11"]
    PIO0_11 = 11,
    #[doc = "12 - PIO1_0"]
    PIO1_0 = 12,
    #[doc = "13 - PIO1_1"]
    PIO1_1 = 13,
    #[doc = "14 - PIO1_2"]
    PIO1_2 = 14,
    #[doc = "15 - PIO1_3"]
    PIO1_3 = 15,
    #[doc = "16 - PIO1_4"]
    PIO1_4 = 16,
    #[doc = "17 - PIO1_5"]
    PIO1_5 = 17,
    #[doc = "18 - PIO1_6"]
    PIO1_6 = 18,
    #[doc = "19 - PIO1_7"]
    PIO1_7 = 19,
    #[doc = "20 - PIO1_8"]
    PIO1_8 = 20,
    #[doc = "21 - PIO1_9"]
    PIO1_9 = 21,
    #[doc = "22 - PIO1_10"]
    PIO1_10 = 22,
    #[doc = "23 - PIO1_11"]
    PIO1_11 = 23,
    #[doc = "24 - PIO2_0"]
    PIO2_0 = 24,
    #[doc = "25 - PIO2_1"]
    PIO2_1 = 25,
    #[doc = "26 - PIO2_2"]
    PIO2_2 = 26,
    #[doc = "27 - PIO2_3"]
    PIO2_3 = 27,
    #[doc = "28 - PIO2_4"]
    PIO2_4 = 28,
    #[doc = "29 - PIO2_5"]
    PIO2_5 = 29,
    #[doc = "30 - PIO2_6"]
    PIO2_6 = 30,
    #[doc = "31 - PIO2_7"]
    PIO2_7 = 31,
    #[doc = "32 - PIO2_8"]
    PIO2_8 = 32,
    #[doc = "33 - PIO2_9"]
    PIO2_9 = 33,
    #[doc = "34 - PIO2_10"]
    PIO2_10 = 34,
    #[doc = "35 - PIO2_11"]
    PIO2_11 = 35,
    #[doc = "36 - PIO3_0"]
    PIO3_0 = 36,
    #[doc = "37 - PIO3_1"]
    PIO3_1 = 37,
    #[doc = "38 - PIO3_2"]
    PIO3_2 = 38,
    #[doc = "39 - PIO3_3"]
    PIO3_3 = 39,
    #[doc = "40 - I2C0"]
    I2C0 = 40,
    #[doc = "41 - CT16B0"]
    CT16B0 = 41,
    #[doc = "42 - CT16B1"]
    CT16B1 = 42,
    #[doc = "43 - CT32B0"]
    CT32B0 = 43,
    #[doc = "44 - CT32B1"]
    CT32B1 = 44,
    #[doc = "45 - SSP0"]
    SSP0 = 45,
    #[doc = "46 - UART"]
    UART = 46,
    #[doc = "47 - USB"]
    USB = 47,
    #[doc = "48 - USBFIQ"]
    USBFIQ = 48,
    #[doc = "49 - ADC"]
    ADC = 49,
    #[doc = "50 - WDT"]
    WDT = 50,
    #[doc = "51 - BOD"]
    BOD = 51,
    #[doc = "53 - PIO_3"]
    PIO_3 = 53,
    #[doc = "54 - PIO_2"]
    PIO_2 = 54,
    #[doc = "55 - PIO_1"]
    PIO_1 = 55,
    #[doc = "56 - PIO_0"]
    PIO_0 = 56,
    #[doc = "57 - SSP1"]
    SSP1 = 57,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "I2C-bus controller"]
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2c::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C").finish()
    }
}
#[doc = "I2C-bus controller"]
pub mod i2c;
#[doc = "Windowed WatchDog Timer (WWDT)"]
pub struct WWDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDT {}
impl WWDT {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const wwdt::RegisterBlock = 0x4000_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wwdt::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WWDT {
    type Target = wwdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WWDT {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WWDT").finish()
    }
}
#[doc = "Windowed WatchDog Timer (WWDT)"]
pub mod wwdt;
#[doc = "UART"]
pub struct UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART {}
impl UART {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART {
    type Target = uart::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART").finish()
    }
}
#[doc = "UART"]
pub mod uart;
#[doc = "16-bit counter/timers (CT16B0/1)"]
pub struct CT16B0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT16B0 {}
impl CT16B0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ct16b0::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ct16b0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CT16B0 {
    type Target = ct16b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CT16B0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CT16B0").finish()
    }
}
#[doc = "16-bit counter/timers (CT16B0/1)"]
pub mod ct16b0;
#[doc = "16-bit counter/timers (CT16B0/1)"]
pub struct CT16B1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT16B1 {}
impl CT16B1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ct16b0::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ct16b0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CT16B1 {
    type Target = ct16b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CT16B1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CT16B1").finish()
    }
}
#[doc = "16-bit counter/timers (CT16B0/1)"]
pub use ct16b0 as ct16b1;
#[doc = "32-bit counter/timers (CT32B0/1)"]
pub struct CT32B0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT32B0 {}
impl CT32B0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ct32b0::RegisterBlock = 0x4001_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ct32b0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CT32B0 {
    type Target = ct32b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CT32B0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CT32B0").finish()
    }
}
#[doc = "32-bit counter/timers (CT32B0/1)"]
pub mod ct32b0;
#[doc = "32-bit counter/timers (CT32B0/1)"]
pub struct CT32B1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT32B1 {}
impl CT32B1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ct32b0::RegisterBlock = 0x4001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ct32b0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CT32B1 {
    type Target = ct32b0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CT32B1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CT32B1").finish()
    }
}
#[doc = "32-bit counter/timers (CT32B0/1)"]
pub use ct32b0 as ct32b1;
#[doc = "Analog-to-Digital Converter (ADC)"]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc::RegisterBlock = 0x4001_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC").finish()
    }
}
#[doc = "Analog-to-Digital Converter (ADC)"]
pub mod adc;
#[doc = "USB device"]
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usb::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usb::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USB").finish()
    }
}
#[doc = "USB device"]
pub mod usb;
#[doc = "Power Management Unit (PMU)"]
pub struct PMU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PMU {}
impl PMU {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmu::RegisterBlock = 0x4003_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PMU {
    type Target = pmu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PMU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PMU").finish()
    }
}
#[doc = "Power Management Unit (PMU)"]
pub mod pmu;
#[doc = "Flash memory programming firmware"]
pub struct FMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FMC {}
impl FMC {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fmc::RegisterBlock = 0x4003_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fmc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FMC {
    type Target = fmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FMC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FMC").finish()
    }
}
#[doc = "Flash memory programming firmware"]
pub mod fmc;
#[doc = "SSP0/1"]
pub struct SSP0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SSP0 {}
impl SSP0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ssp0::RegisterBlock = 0x4004_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ssp0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SSP0 {
    type Target = ssp0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SSP0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SSP0").finish()
    }
}
#[doc = "SSP0/1"]
pub mod ssp0;
#[doc = "I/O configuration"]
pub struct IOCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOCON {}
impl IOCON {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const iocon::RegisterBlock = 0x4004_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const iocon::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IOCON {
    type Target = iocon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IOCON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IOCON").finish()
    }
}
#[doc = "I/O configuration"]
pub mod iocon;
#[doc = "System configuration"]
pub struct SYSCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCON {}
impl SYSCON {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const syscon::RegisterBlock = 0x4004_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const syscon::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SYSCON {
    type Target = syscon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SYSCON {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SYSCON").finish()
    }
}
#[doc = "System configuration"]
pub mod syscon;
#[doc = "SSP0/1"]
pub struct SSP1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SSP1 {}
impl SSP1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ssp0::RegisterBlock = 0x4005_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ssp0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SSP1 {
    type Target = ssp0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SSP1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SSP1").finish()
    }
}
#[doc = "SSP0/1"]
pub use ssp0 as ssp1;
#[doc = "General Purpose I/O (GPIO)"]
pub struct GPIO0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO0 {}
impl GPIO0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x5000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO0 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO0").finish()
    }
}
#[doc = "General Purpose I/O (GPIO)"]
pub mod gpio0;
#[doc = "General Purpose I/O (GPIO)"]
pub struct GPIO1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO1 {}
impl GPIO1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x5001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO1 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO1").finish()
    }
}
#[doc = "General Purpose I/O (GPIO)"]
pub use gpio0 as gpio1;
#[doc = "General Purpose I/O (GPIO)"]
pub struct GPIO2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO2 {}
impl GPIO2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x5002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO2 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO2").finish()
    }
}
#[doc = "General Purpose I/O (GPIO)"]
pub use gpio0 as gpio2;
#[doc = "General Purpose I/O (GPIO)"]
pub struct GPIO3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO3 {}
impl GPIO3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x5003_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIO3 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIO3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIO3").finish()
    }
}
#[doc = "General Purpose I/O (GPIO)"]
pub use gpio0 as gpio3;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "I2C"]
    pub I2C: I2C,
    #[doc = "WWDT"]
    pub WWDT: WWDT,
    #[doc = "UART"]
    pub UART: UART,
    #[doc = "CT16B0"]
    pub CT16B0: CT16B0,
    #[doc = "CT16B1"]
    pub CT16B1: CT16B1,
    #[doc = "CT32B0"]
    pub CT32B0: CT32B0,
    #[doc = "CT32B1"]
    pub CT32B1: CT32B1,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "USB"]
    pub USB: USB,
    #[doc = "PMU"]
    pub PMU: PMU,
    #[doc = "FMC"]
    pub FMC: FMC,
    #[doc = "SSP0"]
    pub SSP0: SSP0,
    #[doc = "IOCON"]
    pub IOCON: IOCON,
    #[doc = "SYSCON"]
    pub SYSCON: SYSCON,
    #[doc = "SSP1"]
    pub SSP1: SSP1,
    #[doc = "GPIO0"]
    pub GPIO0: GPIO0,
    #[doc = "GPIO1"]
    pub GPIO1: GPIO1,
    #[doc = "GPIO2"]
    pub GPIO2: GPIO2,
    #[doc = "GPIO3"]
    pub GPIO3: GPIO3,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            I2C: I2C {
                _marker: PhantomData,
            },
            WWDT: WWDT {
                _marker: PhantomData,
            },
            UART: UART {
                _marker: PhantomData,
            },
            CT16B0: CT16B0 {
                _marker: PhantomData,
            },
            CT16B1: CT16B1 {
                _marker: PhantomData,
            },
            CT32B0: CT32B0 {
                _marker: PhantomData,
            },
            CT32B1: CT32B1 {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            PMU: PMU {
                _marker: PhantomData,
            },
            FMC: FMC {
                _marker: PhantomData,
            },
            SSP0: SSP0 {
                _marker: PhantomData,
            },
            IOCON: IOCON {
                _marker: PhantomData,
            },
            SYSCON: SYSCON {
                _marker: PhantomData,
            },
            SSP1: SSP1 {
                _marker: PhantomData,
            },
            GPIO0: GPIO0 {
                _marker: PhantomData,
            },
            GPIO1: GPIO1 {
                _marker: PhantomData,
            },
            GPIO2: GPIO2 {
                _marker: PhantomData,
            },
            GPIO3: GPIO3 {
                _marker: PhantomData,
            },
        }
    }
}
